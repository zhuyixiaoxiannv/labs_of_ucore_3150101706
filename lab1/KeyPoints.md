## 本文档用于记录在lab1实验中遇到的一些关键的知识点，便于后面复习（虽然也会在report中体现）

### Makefile相关

（在本目录下也放着一份GNUmake中文手册，其实里面很多东西都有，只是没有必要全都弄一遍）

#### 变量定义

简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。
递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。
**条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。**
追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。

#### 引用

$(变量)

如果引用shell操作，则使用$(shell + shell命令)
例如
INCDIR	:=$ (shell pwd)
获取当前路径

如果引用别的函数
使用$(call function)
这个funtion也可以在别的mk文件中
mk文件就是专门用于Makefile的

$(error TEXT…)
报错并且退出执行
$(warning TEXT...)
生成一句warning，但是不会退出执行
$(info TEXT...)
显示一句话

$(eval )

#### 预定义的一些符号和标志
.SUFFIXES	表示合法的文件后缀
.DELETE_ON_ERROR	如果编译中断的话，则删除目标文件

ifndef
......
else
......
endif
判断是否定义某个标识符

#### 工具
objcopy是将二进制文件链接到可执行文件中的
objdump则是查看内容的（表示并不很明白）

#### 其他

projectile文件是Emacs的管理工具吧

反正我用vim

### qemu模拟和gdb相关

（部分复制了report我写的内容，但并不完全）

我只描述在我的系统环境配置下需要做的事情
首先，编译的时候需要指定Makefile里面加上-g允许调试信息，这是前置条件
其次，编译完了之后，使用

```
qemu-system-i386 -s -S -hda bin/ucore.img -monitor vc --nographic
```

打开qemu
最后，建一个新窗口用

```
gdb -tui -x tools/gdbinit
```

打开带text ui的gdb并使用设定好的gdbinit文件
如果不需要的话呢，可以自己设定gdb的断点，tui也可以不用

然后用

```
target remote localhost:1234
```

来连接到qemu的模拟器

然后关于用gdb调试

```
break *0x地址
```

打断点

```
x /10i 0x地址
```

表示执行地址随后的10条instructions

用

```
si
```

指令单步执行。

其他的，比如quit退出等等可以自行参照



### 硬件复位后执行的第一条指令

```
9.1.4执行的第一条指令

硬件复位后获取并执行的第一条指令位于物理地址FFFFFFF0H。此地址比处理器的最高物理地址低16个字节。包含软件初始化代码的EPROM必须位于此地址。

在实地址模式下，地址FFFFFFF0H超出了处理器的1 MB可寻址范围。如下将处理器初始化为该起始地址。 CS寄存器有两个部分：可见段选择器部分和隐藏基地址部分。在实地址模式下，通常通过将16位段选择器值向左移动4位以生成20位基地址来形成基地址。但是，在硬件复位期间，CS寄存器中的段选择器将加载F000H，基地址将加载FFFF0000H。因此，通过将基地址加到EIP寄存器中的值（即FFFF0000 + FFF0H = FFFFFFF0H）来形成起始地址。

硬件重置后，第一次在CS寄存器中加载新值时，处理器将遵循正常规则以实地址模式进行地址转换（即[CS基地址= CS段选择器* 16]）。为确保在完成基于EPROM的软件初始化代码之前，CS寄存器中的基址保持不变，该代码不得包含远跳转或远调用或允许发生中断（这将导致CS选择器值被更改） 。
```
### A20地址线相关

原来我以前和ucore所看的A20地址线的文档是同一篇百度文档。。。事实上，xv6应该也是这么做的。好了不说废话了。

```
8042有4个寄存器

1个8-bit长的Input buffer；Write-Only；

1个8-bit长的Output buffer； Read-Only；

1个8-bit长的Status Register；Read-Only；

1个8-bit长的Control Register；Read/Write。

    有两个端口地址：60h和64h。

读60h端口，读output buffer
写60h端口，写input buffer
读64h端口，读Status Register
    对Control Register的操作相对要复杂一些，首先要向64h端口写一个命令（20h为读命令，60h为写命令），然后根据命令从60h端口读出Control Register的数据或者向60h端口写入Control Register的数据（64h端口还可以接受许多其它的命令）。

    先来看看Status Register的定义，我们后面要用bit 0和bit 1：

    bit    meaning
    -----------------------------------------------------------------------
     0     output register (60h) 中有数据
     1     input register (60h/64h) 有数据
     2     系统标志（上电复位后被置为0）
     3     data in input register is command (1) or data (0)
     4     1=keyboard enabled, 0=keyboard disabled (via switch)
     5     1=transmit timeout (data transmit not complete)
     6     1=receive timeout (data transmit not complete)
     7     1=even parity rec'd, 0=odd parity rec'd (should be odd)

    除了这些资源外，8042还有3个内部端口：Input Port、Outport Port和Test Port，这三个端口的操作都是通过向64h发送命令，然后在60h进行读写的方式完成，其中本文要操作的A20 Gate被定义在Output Port的bit 1上，所以我们有必要对Outport Port的操作及端口定义做一个说明。

读Output Port
向64h发送0d0h命令，然后从60h读取Output Port的内容
写Output Port
向64h发送0d1h命令，然后向60h写入Output Port的数据
    另外我们还应该介绍两个命令：

禁止键盘操作命令
向64h发送0adh
打开键盘操作命令
向64h发送0aeh
    有了这些命令和知识，我们可以考虑操作A20 Gate了，有关8042芯片更详细的资料，请参考该芯片的Data Sheet。

     如何打开和关闭A20 Gate。

    理论上讲，我们只要操作8042芯片的输出端口（64h）的bit 1，就可以控制A20 Gate，但实际上，当你准备向8042的输入缓冲区里写数据时，可能里面还有其它数据没有处理，所以，我们要首先禁止键盘操作，同时等待数据缓冲区中没有数据以后，才能真正地去操作8042打开或者关闭A20 Gate。打开A20 Gate的具体步骤大致如下：

    1.关闭中断；
    2.等待8042 Input buffer为空；
    3.发送禁止键盘操作命令；
    4.等待8042 Input buffer为空；
    5.发送读取8042 Output Port命令；
    6.等待8042 Output buffer有数据；
    7.读取8042 Output buffer，并保存得到的字节；
    8.等待8042 Input buffer为空；
    9.发送Write 8042 Output Port命令到8042 Input buffer；
    10.等待8042 Input buffer为空；
    11.将从8042 Output Port得到的字节的第2位置1（或清0），然后写入8042 Input buffer；
    12.等待，直到8042 Input buffer为空为止；
    13.发送允许键盘操作命令到8042 Input buffer；
    14. 打开中断。
```

(总感觉又回到了被硬件电路支配的日子)上面的步骤，主要是

1、等待input buffer为空然后禁止键盘操作，此时可以安全的操作了

2、发送读取output buffer的信号并读取保存得到的东西，然后将保存的东西，第二位置位，再送回去

3、允许键盘操作

我觉得这样做是较为安全的，但是，对于ucroe的方法也未必是错的。它的做法省略了几个步骤，首先，并没有关闭键盘操作这件事——就目前的CPU速度而言，这没什么大的问题。其次，他没有读取再置位后写回，而是直接赋值了，这可能会引起一些错误——但我觉得其实差别不会很大。

其中，0x64端口是控制指令，0x60端口是数据

```
0xd1->Port 0x64 向P2输出端口写命令
```

另外

```
后来，由于感觉使用8042控制A20运行太慢了（确实，那么长的代码，中间还要若干次的wait），所以后来又出现了所谓的Fast A20，实际上，现在的大多数机器都是Fast A20，Fast A20使用92h端口控制A20，同时BIOS里提供了一个软中断来控制A20：

    入口：ah=24h
          al=0    关闭A20
             1    打开A20
             2    读取A20状态
          int 15h

    返回：如果BIOS支持此功能，CF=0，否则CF=1
          CF=0时，AX返回当前A20状态，1=打开，0=关闭

    像8042中的Output Port中的定义一样，92h端口的bit 1控制着A20，为1时打开，为0时关闭，从92h中读一个byte可以看a20的当前状态，所以对92h的操作如下：

读A20状态
mov dx, 92h
in al, dx
如果al的bit 1为1表示a20打开，否则为0
打开A20
mov dx, 92h
mov al, 02
out dx, al
关闭A20
mov dx, 92h
mov al, 0
out dx, al
    特别要注意的是，大家从这篇文章的文字中可能也能感觉到，A20 Gate的设计本身就让人感觉很别扭，不是那么流畅，所以和A20有关的事情就难免也会有相同的感觉，很奇怪的是，上面介绍的三种方法并不是在每台机器上都适用，所以如果你要做一个商业软件其中要操作A20，那一定要三种方式联合使用才比较稳妥，否则会有意想不到的结果，LINUX公开的启动代码中就是这么做的
```

如果是这样的话，会简单很多，但即便如此，我想，请务必多种方法联合使用。。。

TODO：将Fast A20方案写进代码，使得其更完善

（PS：个人认为对于一个正式用的操作系统而言，显然512字节是不够用的，所以应该设计为2级加载模式，第一级的512字节只是把需要的第二级加载程序的内容加载到内存中，而第二级加载程序再进行所谓的进入保护模式，设置GDT，设置分段分页等等工作。另外考虑到所谓的文件系统，如果有需要的话，显然，我觉得，磁盘的开头第一个扇区应该设计为BootLoader没毛病，第二个及之后的几个扇区则设置为第二级加载程序。之后从文件系统加载。）

### GDT相关

每个程序都用一个段描述符来表示一个段使用的内存空间

当然关于段描述符的具体内容并不在此处展开，太长了这些字段

这些段描述符组合起来称为段描述符表，并且GDT表的第一个描述符是不使用的。lgdt和sgdt用于访问GDTR寄存器，lldt和sldt访问LDTR寄存器，但访问LDTR的lldt指令使用的操作数表示GDT表中一个描述符项的选择符，即LDT是一个在GDT表中存在的段

段寄存器，总共16位。在实模式下是指某个基地址。但在保护模式下则是指向某个描述符
然鹅GDT表的长度最多2的13次也就是8192个，因为每个描述符占用8字节，所以最后3位是0


### 保护模式开启

我发现，虽然在代码中写了下面几句：

```
    movl %cr0, %eax
    orl $CR0_PE_ON, %eax
    movl %eax, %cr0
```

但是在实验说明中并没有包括这部分的知识，因此我来记录一下（虽然之前已经了解过了）

正确的理由其实得看Intel的80386手册，我这边就写一下

80386总共有4个控制寄存器，CR0-3

其中CR0存在几个重要的位

PE——保护模式开启位，bit0

TS——任务切换位，bit3

PG——分页操作位，bit31，指示是否使用页表将线性地址转换为物理地址

### 硬盘访问操作

硬盘分为CHS和LBA模式

CHS模式即为磁头柱面扇区,。
磁头（heads）表示有几个磁头，也就是有几个盘片，最大256。（8位2进制）
柱面（Cylinders）表示硬盘每个面的盘片上面有几个磁道。最大1024。（10位）
扇区每个磁道上面多少个扇区。最大63。（0扇区不用，所以从1-63，共63个）
每个扇区512字节。
但是这意味着内圈的一个扇区和外圈的一个扇区都是512字节，很浪费空间。

这个时候采用了线性的寻址，按照扇区数来寻址了。两者的转换为
LBA=（C-Cs）*PH*PS+（H-Hs）*PS+（S-Ss） 

一般情况下，CS=0、HS=0、SS=1；PS=63、PH=255，具体缘由见前面的介绍，我觉得这很简单去理解。

C=LBA DIV (PH*PS) + Cs 
H=(LBA DIV PS) MOD PH + Hs 
S=LBA MOD PS + Ss

（就是一个反向操作）

硬盘的读取如下：
```
一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。

表一 磁盘IO地址和对应功能

IO地址	功能
0x1f0	读数据，当0x1f7不为忙状态时，可以读。
0x1f2	要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区
0x1f3	如果是LBA模式，就是LBA参数的0-7位
0x1f4	如果是LBA模式，就是LBA参数的8-15位
0x1f5	如果是LBA模式，就是LBA参数的16-23位
0x1f6	第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘，第6位：为1=LBA模式；0 = CHS模式 第7位和第5位必须为1
0x1f7	状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据

1. 等待磁盘准备好
2. 发出读取扇区的命令
3. 等待磁盘准备好
4. 把磁盘扇区数据读到指定内存
```
简单来说，就是，把这么几个端口，作为一个数据结构，然后给0x1f7端口写指令，从0x1f0端口读取数据。
0x1F1是端口的错误寄存器，里面保留着“硬盘驱动器”最后一次执行工作的时候状态。（错误原因。）
另外，对于控制命令，outb到0x1f7时候，cmd 0x20表示请求读，0x30表示请求写
对于0x1f7的状态

| 7          | 6            | 5    | 4    | 3                  | 2    | 1    | 0                |
| ---------- | ------------ | ---- | ---- | ------------------ | ---- | ---- | ---------------- |
| 表示硬盘忙 | 表示硬盘就绪 |      |      | 表示硬盘准备好数据 |      |      | 表示硬盘发生错误 |

表示这个表格就很神奇 。
另外一个很神奇的地方在于，emmm就是这里面的waitdisk函数里面

```
	while ((inb(0x1F7) & 0xC0) != 0x40)
```
这一行代码不要指望我看得懂，我就不明白了，一个什么样的操作数，和0xC0（1000 0000b）进行按位与操作之后，能变成0x40（0010 0000b），我知道它的意思，就是把端口读出来的数据进行检验，可是这在逻辑上真的不通。
算了我不管了

另外，此处使用的是Program IO方式。
加一些备注（虽然貌似都学过一些）
无条件传送方式
应用此方式的数据源设备一定是随时准备好了数据，CPU随时存取都没问题，如寄存器，内存就是类似这样的设备。

查询传送方式
这种查询方式也称为"程序I/O"，是指传输之前，由程序先去检测设备的状态，数据源设备在一定的条件下才能传送数据，这类设备通常是低速设备，比如硬盘，CPU 需要数据时，会先检查该设备的状态。

中断传送方式
上一种是通过"轮询"的方式，探知数据时候准备完毕，效率不高，而中断是通过让数据源在准备好数据的情况下，主动"发中断"来通知CPU来拿数据。

直接存储器存取方式 ( DMA )
在中断传送方式中，虽然极大的提高了CPU的利用率，但通过中断，CPU仍然需要通过压栈来保护现场，还要执行传输命令，最后还要恢复现场，总之还是需要CPU来做一部分工作。更好的方式是不让CPU参与传输，完全由数据源设备和内存直接传输，不过这种方式需要硬件 (DMA 控制器) 实现。

I/O处理机传送方式
在 DMA 这种方式中，虽然数据传输不需要经过CPU，但输入和输出前，仍有一部分工作需要有CPU来完成，如数据交换，组合，校验。于是 I/O处理机诞生了，本质上它是一种处理器，只不过用的是一套擅长 IO 的指令系统。有了它的参与，CPU甚至不知道有数据传输这回事。

### 一些跟GCC和C语言有关的部分
volatile 关键字，告诉编译器，这段代码不要优化，一般写汇编就加上吧

对于GCC内嵌汇编，由于使用的是AT&T而不是Intel的格式。

例如
```
asm(“fsinx %1, %0”:”=f”(result):”f”(angle));
```
其中。fsinx是某个汇编指令（不用管是啥，这个一定是浮点数的sin值，x86肯定没有对应汇编的），两个百分号表示目标操作数，0表示第一个，1表示第二个
括号里面的表示使用的C语言的变量
等于号表示这是一个输出操作数
后面的f表示一个浮点寄存器
常用的有
m    内存操作数
r    寄存器操作数
i    立即数操作数（整数）
f    浮点寄存器操作数
F   立即数操作数（浮点）

### ELF文件格式
目标文件有三种类型：

– 可重定位文件（Relocatable File） 包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。

– 可执行文件（Executable File） 包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像。

– 共享目标文件（Shared Object File） 包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像。

ELF文件格式主要3大部分，ELF文件头，节区表，和节区。对于可执行文件对应的是段表，段。
![elf](.\elf.gif)

如上面的图片所示，一个文件头，ELFHeader，里面包括了e_phoff，从而查找到Program Header Table的位置，以及寻找到程序头数目和Section数目，然后遍历所有的program Header，从中找到每个segment的位置，并加载

但是其实还有一大堆的东西，好在kernel里面，并没有用到别的东西。

https://blog.csdn.net/xiaofei0859/article/details/51121701

这个是一些关于linux下内核加载器加载elf文件的调用，好在我们就是内核，所以不用在乎其他事情，能用就好了呗

### 函数堆栈

（讲真我表示我学过这部分知识，大同小异）函数传参有寄存器传参（适合参数不多的情况），压栈传参（一般比较多）

参考文档的描述是这样的

```
#入栈
pushl   %ebp
movl   %esp , %ebp

+|  栈底方向        | 高位地址
 |    ...        |
 |    ...        |
 |  参数3        |
 |  参数2        |
 |  参数1        |
 |  返回地址        |
 |  上一层[ebp]    | <-------- [ebp]
 |  局部变量        |  低位地址

#其实我觉得还有出栈
#这样的话应该是
#pop %ebp
#ret

这两条汇编指令的含义是：首先将ebp寄存器入栈，然后将栈顶指针esp赋值给ebp。“mov ebp esp”这条指令表面上看是用esp覆盖ebp原来的值，其实不然。因为给ebp赋值之前，原ebp值已经被压栈（位于栈顶），而新的ebp又恰恰指向栈顶。此时ebp寄存器就已经处于一个非常重要的地位，该寄存器中存储着栈中的一个地址（原ebp入栈后的栈顶），从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的ebp值。

一般而言，ss:[ebp+4]处为返回地址，ss:[ebp+8]处为第一个参数值（最后一个入栈的参数值，此处假设其占用4字节内存），ss:[ebp-4]处为第一个局部变量，ss:[ebp]处为上一层ebp值。由于ebp中的地址处总是“上一层函数调用时的ebp值”，而在每一层函数调用中，都能通过当时的ebp值“向上（栈底方向）”能获取返回地址、参数值，“向下（栈顶方向）”能获取函数局部变量值。如此形成递归，直至到达栈底。这就是函数调用栈。
```

(注意esp指针是指向在低地址的，而且是自动变化的，所以不用管)

### stabs格式
参考
http://www.math.utah.edu/docs/info/stabs_toc.html
（不过我没啥耐心看完）

and, actually it seems not used in my work.

### VGA相关

CGA显存按照下面的方式映射：
-- 0xB0000 - 0xB7FFF 单色字符模式
-- 0xB8000 - 0xBFFFF 彩色字符模式及 CGA 兼容图形模式
6845芯片是IBM PC中的视频控制器
CPU通过IO地址0x3B4-0x3B5来驱动6845控制单色显示，通过IO地址0x3D4-0x3D5来控制彩色显示。
-- 数据寄存器 映射 到 端口 0x3D5或0x3B5 
-- 索引寄存器 0x3D4或0x3B4,决定在数据寄存器中的数据表示什么。

### 中断与异常

有三种中断：
IO，时钟这种异步产生（时间不确定的）称为异步中断
CPU执行时候，产生错误，比如除以零或者访问越界等等，称为异常。
低特权级请求系统服务，称为陷入中断

#### 中断描述符表IDT
中断描述符把每个中断指向一个中断服务程序。
IDT是一个8byte的描述符数组，但IDT第一项可以包含一个描述符（GDT的第一个表项是不用的）

IDT可以位于内存任何位置，CPU通过IDT寄存器IDTR来找到IDT的起始位置
LIDT指令：指定IDT的起始位置
SIDT指令：存储IDTR中的内容

IDTR共48位，低16位表示有多少个IDT项，最多256个。IDT_limit
高32位表示IDT起始地址。IDT_base
所以要找某一个中断号n，就是IDT_base+（n-1）*8
最后一个IDT中断就是IDT_base+（IDT_limit-1）*8

对于中断号，其中[0,31]这32个中断号都被保留使用
[32,255]则可以使用

IDT的每个表项都是一个门描述符

总共包含三种门描述符

Task-gate descriptor （这里没有使用）
Interrupt-gate descriptor （中断方式用到）
Trap-gate descriptor（系统调用用到）

门描述符用来控制段访问的时候的一些安全问题（貌似挺复杂，但跟这个关系应该不是很大）

具体三种的门描述符的每个字段的长度和含义我就不说了，有点多

当触发中断时，寻找中断例程的过程为：
首先在IDTR中找到相应的门描述符
门描述符里面有基地址和偏移
基地址是一个段描述符，占16位，就好像一个16位的段寄存器一样，但是实际上是GDT表里面的一个段描述符，然后找到基地址
再跟门描述符里面的偏移相加得到中断例程的入口地址。

