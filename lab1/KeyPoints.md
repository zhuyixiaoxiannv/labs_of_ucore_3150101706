## 本文档用于记录在lab1实验中遇到的一些关键的知识点，便于后面复习（虽然也会在report中体现）

### Makefile相关

（在本目录下也放着一份GNUmake中文手册，其实里面很多东西都有，只是没有必要全都弄一遍）

#### 变量定义

简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。
递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。
**条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。**
追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。

#### 引用

$(变量)

如果引用shell操作，则使用$(shell + shell命令)
例如
INCDIR	:=$ (shell pwd)
获取当前路径

如果引用别的函数
使用$(call function)
这个funtion也可以在别的mk文件中
mk文件就是专门用于Makefile的

$(error TEXT…)
报错并且退出执行
$(warning TEXT...)
生成一句warning，但是不会退出执行
$(info TEXT...)
显示一句话

$(eval )

#### 预定义的一些符号和标志
.SUFFIXES	表示合法的文件后缀
.DELETE_ON_ERROR	如果编译中断的话，则删除目标文件

ifndef
......
else
......
endif
判断是否定义某个标识符

#### 工具
objcopy是将二进制文件链接到可执行文件中的
objdump则是查看内容的（表示并不很明白）

#### 其他

projectile文件是Emacs的管理工具吧

反正我用vim

### qemu模拟和gdb相关

（部分复制了report我写的内容，但并不完全）

我只描述在我的系统环境配置下需要做的事情
首先，编译的时候需要指定Makefile里面加上-g允许调试信息，这是前置条件
其次，编译完了之后，使用

```
qemu-system-i386 -s -S -hda bin/ucore.img -monitor vc --nographic
```

打开qemu
最后，建一个新窗口用

```
gdb -tui -x tools/gdbinit
```

打开带text ui的gdb并使用设定好的gdbinit文件
如果不需要的话呢，可以自己设定gdb的断点，tui也可以不用

然后用

```
target remote localhost:1234
```

来连接到qemu的模拟器

然后关于用gdb调试

```
break *0x地址
```

打断点

```
x /10i 0x地址
```

表示执行地址随后的10条instructions

用

```
si
```

指令单步执行。

其他的，比如quit退出等等可以自行参照



### 硬件复位后执行的第一条指令

```
9.1.4执行的第一条指令

硬件复位后获取并执行的第一条指令位于物理地址FFFFFFF0H。此地址比处理器的最高物理地址低16个字节。包含软件初始化代码的EPROM必须位于此地址。

在实地址模式下，地址FFFFFFF0H超出了处理器的1 MB可寻址范围。如下将处理器初始化为该起始地址。 CS寄存器有两个部分：可见段选择器部分和隐藏基地址部分。在实地址模式下，通常通过将16位段选择器值向左移动4位以生成20位基地址来形成基地址。但是，在硬件复位期间，CS寄存器中的段选择器将加载F000H，基地址将加载FFFF0000H。因此，通过将基地址加到EIP寄存器中的值（即FFFF0000 + FFF0H = FFFFFFF0H）来形成起始地址。

硬件重置后，第一次在CS寄存器中加载新值时，处理器将遵循正常规则以实地址模式进行地址转换（即[CS基地址= CS段选择器* 16]）。为确保在完成基于EPROM的软件初始化代码之前，CS寄存器中的基址保持不变，该代码不得包含远跳转或远调用或允许发生中断（这将导致CS选择器值被更改） 。
```
