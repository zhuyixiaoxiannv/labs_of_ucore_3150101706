#### init

从init函数开始讲起，是因为，这里面有个很玄幻的事情，就是之前做的swap，这里面是先init_proc再考虑swap的。

另一个需要说的事情是，用了cpu_idle()这个函数，它在proc当中被定义，但是在kern_init中最后被调用（这个时候开启了switch。

#### proc_init

然后说说，proc_init。

这里面，先是把进程列表初始化一个头结点，然后生成一个idleproc，但是不是调用kernel_thread，随后生成了第一个进程，然后只是分配了一定的堆栈，等等，换句话说，这里面的工作只是把两个线程的控制块以及属于他们的资源（原谅我用资源，但是其实就是一些堆栈等等）

在之后kern_init里面，调用cpu_idle的时候才正式开启切换。

#### 相关数据结构和comment

主要见proc.c开头那一堆comments，主要是proc这个状态的转变。而这些状态的记录和变更，主要是由进程控制块决定的。

除此之外，进程控制块还要构成一个链表。

#### kmalloc

在之前呢，kmalloc只是pmm里面一个小小的函数，但是现在，变成了一个单独的文件，还有一个slob结构。这里面要用的就kmalloc和kfree——就C代码中字面意思的东西。但是其实现用到了slab的算法。

#### setup_kstack

这里面直接调用物理页分配而不是用虚拟内存系统进行管理，我找到参考材料的一段话：

```
其次，内核栈位于内核地址空间，并且是不共享的（每个线程都拥有自己的内核栈），因此不受到 mm 的管理，当进程退出的时候，内核能够根据 kstack 的值快速定位栈的位置并进行回收。uCore 的这种内核栈的设计借鉴的是 linux 的方法（但由于内存管理实现的差异，它实现的远不如 linux 的灵活），它使得每个线程的内核栈在不同的位置，这样从某种程度上方便调试，但同时也使得内核对栈溢出变得十分不敏感，因为一旦发生溢出，它极可能污染内核中其它的数据使得内核崩溃。如果能够通过页表，将所有进程的内核栈映射到固定的地址上去，能够避免这种问题，但又会使得进程切换过程中对栈的修改变得相当繁琐。
```

