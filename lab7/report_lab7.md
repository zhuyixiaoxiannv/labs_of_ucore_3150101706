开局依然碰见报错，心塞塞，不知道是不是代码复制过去的问题，报一个general protection的错误，

运行的代码，有两个一个是用于测试的，

```
make grade
```

还有一个用于正常操作的，同lab4

```
qemu-system-i386 -s -hda bin/ucore.img -drive file=./bin/swap.img,media=disk,cache=writeback -monitor vc --nographic
```

我表示一脸懵逼，如果说前面内核态还能像个程序一样调试的话，现在这个用户态就很。。。

报的错是general protection，然后呢，做的事情是访问系统的TSS段。。。？这不是显然会出错吗？

emmmm于是我去找了lab6，没错啊，lab6改成运行badsegment也会有这个问题啊，那就不是代码的问题，对吧好好地哈哈哈哈。那为啥lab6的make grade就没事啊。哦，可能是，这个lab7的代码跑起来有点慢。。。因为时钟的问题。算了等着吧。慢慢先看看这个project让人做什么。我去写KeyPoints了。

哦，那没事了，就一件事，这个代码跑起来有点慢。手动狗头。

# 练习0：填写已有实验

本实验依赖实验1/2/3/4/5/6。请把你做的实验1/2/3/4/5/6的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab7的测试应用程序，可能需对已完成的实验1/2/3/4/5/6的代码进行进一步改进。

#### answers:
把代码拷贝过去就完了

# 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）

完成练习0后，建议大家比较一下（可用kdiff3等文件比较软件）个人完成的lab6和练习0完成后的刚修改的lab7之间的区别，分析了解lab7采用信号量的执行过程。执行make grade，大部分测试用例应该通过。

请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。

请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

#### Answers：
除了lab6里面的优先级的部分，其他都能过

#### 信号量：

```
typedef struct {
    int value;                           //信号量的当前值
    wait_queue_t wait_queue;     //信号量对应的等待队列
} semaphore_t;
```

数据结构的描述如上面所述，大概就是当前信号量的值，和对应的等待队列，等待队列要看那个底层支撑，就是一个出入队列的问题，不是很关键。

PV操作没有那么麻烦，就是操作系统里面学到的基础，这里面用一个down函数和up函数

注意一段描述：

```
value>0，表示共享资源的空闲数
vlaue<0，表示该信号量的等待队列里的进程数
value=0，表示等待队列为空
```

这里面value==0的地方，共享资源已经没了，但是也没有新的进程申请共享资源。

#### 哲学家进餐的信号量实现的过程

每个哲学家用一个philosopher_using_semaphore的内核进程来表示，这里面调用了两个函数，一个是拿叉子，一个是放回叉子，而在拿叉子和放回的叉子的过程中调用了信号量，让叉子不能被别的进程所访问。

在拿叉子和取叉子当中的信号量，则是由sem.h里面定义的一个down和一个up函数实现，注意一下下这里面的monitor则是管程的文件，跟这个没啥太大关系

而这个down和up里面则主要是对这个信号量的管理，如果有能使用的资源，那么就减减，然后返回，否则就置位wait然后让他schedule，schedule完了之后还跑到这行，就继续跑。

这里面的proc的状态并不是runnable，只缺处理机。而是缺少这个信号量，属于阻塞态的。

另外就是一个wait这个queue的处理操作。用了一个wait_t的结构体。

（说来复杂，其实看看代码就完了，讲真我觉得懂了PV操作之后，加个队列，也就这样的内容了。

#### 请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

对于用户态进程/线程想要使用信号量机制，基本就是要在trap里的systemcall里面加东西了， 操作系统内核直接调用就完事了。

信号量主要包括一个value和相应队列，以及相关的PV操作，PV操作显然是需要分别弄一个systemcall的，另外还需要有创建申请信号量以及撤销一个信号量的操作。

# 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）

首先掌握管程机制，然后基于信号量实现完成条件变量实现，然后用管程机制实现哲学家就餐问题的解决方案（基于条件变量）。

执行：make grade 。如果所显示的应用程序检测都输出ok，则基本正确。如果只是某程序过不去，比如matrix.c，则可执行 make run-matrix 命令来单独调试它。大致执行结果可看附录。（使用的是**qemu-1.0.1**）。

请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程。

请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。

感觉要我做的事情其实很少，要我填写的代码，check_sync里面基本上和使用信号量的东西差不多，然后monitor里面基本上都给出来了。并不明白有什么要加的。（不过过会和答案对照一下下吧）
u1s1，这个感觉make grade之后，并不能充分判断这个写的对不对啊。一脸迷茫。
哦，我这边跑不下去了，基本就是说，好像确实有些不对劲的地方。反正跑着跑着凉了就是跑的不对是吧啊哈哈哈。
哔了狗了，真的跑完了。我自己都没读懂这管程讲的啥玩意儿，就照着写，然后就完了，这就是传说中的thu，负重前行的永远都是老师和助教嘛。。。笑哭了我。

顺带看了一下下lab7_result的代码，基本差不多，但是这边，有一个，cond_wait的函数忘记了，大概，这么说吧，不然就根本没有用到这个函数的地方了。要注意对称性。其实不是对不对称的事情，而是这种变量，没有被阻塞的考虑。so。。。洗洗睡吧。

另外还有就是sleep里面缺少一个正确性的东西，我不知道怎么回事。小老弟你怎么回事。

至于lab7_results，小老弟，这简直不行啊，直接跑都能出点毛病。。。小老弟，你太惨了。不过我觉得不是什么大问题倒是真的。至于那个sleep是什么鬼，为什么怎么弄都要跑那么久

（顺带一说，上次清理磁盘，直接删了git。。。真的mmp）

emmm对于那个lab7里面priority的错误是，因为lab6里面的进程调度优先度的问题，那么在sleep里面的问题，我把check_sycn注释掉不运行之后，依然存在，说明跟本实验的关系不是很大。看了具体代码之后我个人的猜想是，就是，由于sleep里面涉及到对于时间的读取，而在模拟器中的时间读取其实前面也一直报错误，所以可能跟这个有关系。

他说

```
use 99999 msecs.
```

大概。。。是我太菜了吧，我怎么怎么觉得这像是超时了的样子。不应该啊。

我查看了一下下，开始时间是1，结束时间是

```
time is:00100000.
```

而且跑出来整整齐齐，所以我觉得是，grade检测方式的问题，估计是这个写错了，那，不管了。

明天写一下管程这个的理解（我感觉看的贼晕乎乎的）


# Linux 的 RCU

