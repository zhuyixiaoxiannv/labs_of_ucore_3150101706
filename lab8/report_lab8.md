运行的代码，有两个一个是用于测试的，

```
make grade
```

还有一个用于正常操作的，同lab4

```
qemu-system-i386 -s -hda bin/ucore.img -drive file=./bin/swap.img,media=disk,cache=writeback -drive file=./bin/sfs.img,media=disk,cache=writeback -monitor vc --nographic
```

这里面参考一下下Makefile，就是说，需要多加一个disk了，作为文件系统。容我看看Makefile。

他大概就是多加了一个disk，写成上面那个就很舒服了。能用，但是恐怕得去看看那个driver的代码了。

emmm相关理解部分我写在KeyPoints里面了。至于跑的时候报了一个什么乱七八糟的pagefault的错误，我估摸着，应该是，那个load_icode的部分，那整个直接给空了，没给人新的进程创建memory，可不能不出错啊。

# 练习0：填写已有实验

本实验依赖实验1/2/3/4/5/6/7。请把你做的实验1/2/3/4/5/6/7的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6” /“LAB7”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab8的测试应用程序，可能需对已完成的实验1/2/3/4/5/6/7的代码进行进一步改进。

#### answers：
反正写完了跑不了，就酱紫，能说什么。

# 练习1: 完成读文件操作的实现（需要编码）
首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，编写在sfs_inode.c中sfs_io_nolock读文件中数据的实现代码。

请在实验报告中给出设计实现”UNIX的PIPE机制“的概要设方案，鼓励给出详细设计方案

#### answers：
这部分对应了读文件这件事情。

看了大半天，原来超级简单
首先考虑读取的offset和endpos都在一个块内的情况
如果不是，那么从开头读取不到一个4k的，然后循环找，然后再找结尾——这里面需要考虑endpos和offset在一个块内的情况，也就是读取的长度==0的时候，这个时候，就不要读取了。
我第一次写的代码其实和答案有一定差别，但是，其实意思差不多。无非是实现的方式，以及需要注意的细节部分。毕竟那个blkoff定义在那么前面还没个注释，然后alen是啥我也不清楚，真。。。让人难过。

#### UNIX的PIPE机制


# 练习2: 完成基于文件系统的执行程序机制的实现（需要编码）
改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。执行：make qemu。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可以执行”ls”,”hello”等其他放置在sfs文件系统中的其他执行程序，则可以认为本实验基本成功。

请在实验报告中给出设计实现基于”UNIX的硬链接和软链接机制“的概要设方案，鼓励给出详细设计方案

#### answers：
这应该对应一各加载器的部分。
我觉得首先得看看之前的load_icode是怎么实现的。那玩意老长，而且感觉很多代码可以照抄，毕竟，怎么说呢，内存分配部分其实差不多。
有区别的是，读取文件的部分，一个是内存中直接拷贝，见之前的user的实验，而现在则是需要从文件读取。基于fd这个文件句柄。

这里面需要记录一下file这个结构
```
struct file {
    enum {
        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,
    } status;
    bool readable;
    bool writable;
    int fd;
    off_t pos;
    struct inode *node;
    int open_count;
};
```
所得到的的文件句柄是这个结构里面的fd，所以需要从这个结构得到struct inode

另外，实验出于测试目的，还写了sh.c文件，相当于一个linux的shell。proc.c里面也有很多其他地方的更改，有兴趣可以进行和lab7的对比。
#### load_icode
这边送了一个函数调用load_icode_read，免去了一大堆的读写麻烦。——但是并不是很明白这个buff该怎么处理，是说一口气读进来整个文件然后按照这个buff的内容再搞事情呢（因为反正文件也不是很大对吧）。还是说只把开头的部分读取进来，然后根据需要再进行读取呢？如果只考虑空间，那肯定后者好，因为这里面需要为了buff再开辟一个空间，反之，前者会减少读取磁盘的次数，因为一整个读进来就好了，后者还要考虑一大堆东西，我个人倾向于后者。没了。

不得不说，这块内存的处理（尤其是那几个函数的乱七八糟的变量，还没得说明emmm尽管看意思就能明白但是，毕竟太多了不是嘛）是我遇到的第一个难题。
ok下面的一些工作准备好之后，基本上就是把lab7里面的东西复制过来即可，有区别的地方在于一个elf和prohdr的读取和内存拷贝的变成了文件读取。

#### argv和argc

之前的工作其实没有考虑这个问题，直到我发现如果不管这个事情，会报那个vma缺少栈顶地址的错误。因为参数是压栈的方式传给子函数的，所以应该是这个问题。emmm今天不早了，我先把代码传了，剩下的解读，就明天再说吧。

#### proc结构初始化里面的工作
好吧在这之前，还要弄一下proc里面，alloc一个proc结构时候的工作。就是需要初始化里面的fs的结构，感觉根本就没找到那个fs就gg了，我再去看看。但是idleproc没毛病啊，这里面用了一个idleproc->filesp = files_create()
但是貌似这并没有什么卵用

#### fork里面增加的部分
找了一圈，原来fork也要增加。
只是增加一个copy_files即可

