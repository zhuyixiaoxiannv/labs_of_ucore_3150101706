# 练习1：给未被映射的地址映射上物理页（需要编程）

完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。注意：在LAB2 EXERCISE 1处填写代码。执行

```
make　qemu
```

后，如果通过check_pgfault函数的测试后，会有“check_pgfault() succeeded!”的输出，表示练习1基本正确。

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
- 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

#### Answer：

最主要还是pte这个结构，在**存在位置位**的情况下，**pte表示的是页表里面的某个页**，但是如果不为零且**存在位不置位**，则说明，换到磁盘上面去，这个时候，**pte表示的是磁盘上的扇区号**（参考指导材料那个挂羊头卖狗肉的“页面置换机制实验报告要求”


# 练习2：补充完成基于FIFO的页面替换算法（需要编程）

完成vmm.c中的do_pgfault函数，并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_vistim函数。通过对swap的测试。注意：在LAB2 EXERCISE 2处填写代码。执行

```
make　qemu
```

后，如果通过check_swap函数的测试后，会有“check_swap() succeeded!”的输出，表示练习2基本正确。

请在实验报告中简要说明你的设计实现过程。

请在实验报告中回答如下问题：

- 如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题
  - 需要被换出的页的特征是什么？
  - 在ucore中如何判断具有这样特征的页？
  - 何时进行换入和换出操作？

#### Makefile和qemu参数的更改

这里面对照着Makefile of lab1，会发现增加了参数，原因是，需要有一个交换的盘，不然会有一个报错swap fs isn't available.我查看了一下网上的答案，都是由两个ide，但是我这边缺少一个ide，联系到具体的内容是把页交换到磁盘上面，所以肯定是缺少了交换盘的文件。因为我这边实在win下的WSL环境下（lab1报告中有讲到），导致直接运行make qemu会有问题，所以这边记录一下正确的qemu的参数，由于make命令中，生成了/dev/zero这个img，所以不用担心找不到这个文件，但是问题是，这个文件虽然在，但是却没有内容，也就是size==0。事实上用到的是bin文件夹下面的swap.img。

```
qemu-system-i386 -s -hda bin/ucore.img -drive file=./bin/swap.img,media=disk,cache=writeback -monitor vc --nographic
```

这样就不会报这个错误了。

OK这样就好了。

要我们写的代码的意思，首先既然报了页缺失中断了，那么，如果找到那个pte（pte一定会有的，无非，是不是新生成一个，按照这个自映射机制，应该不太会），里面的内容为0，也就是说，没有对应的物理页，那么alloc一个物理页，然后调用page_insert()来搞定——正如lab2所说，这个page_insert可以将一个虚拟地址映射到一个物理页框里面去。

如果找到那个pte，但是里面内容不为0，说明这个物理页框是在的。但是，物理页框的存在位是没有置位，也就是这个物理页被别的内容占据了，所以需要使用页面置换，然后把这个物理页框的内容用磁盘上面的内容写入。

哦不对，这个系统不是这么做的，在swap_in里面，是申请了新的一页，磁盘上的内容写入，然后把这个地址给传出来，再调用page_insert修改pte指向的那个物理页框，

(但是其中一个让我比较疑惑的地方在于，如果按照设计的话，vma应该每个节点可以包含多个page，然而这样一次只能换出一页，几次置换之后，基本上都是零碎的一页一页的了，所以意义在哪里。)

关于换出swap_out的问题。

这里面swap_out 的时机，参考pmm.c里面alloc_pages（和lab2的对比），发现每次分配页的时候，~~分配多少页，就调出多少页。~~（尽管我不觉得这是最优的方式）emmm是物理内存空间不够的时候，就给他调出一页。

#### 总结一下流程

感觉有点乱，我还是总结一下

首先就是那个mm，用于管理所有被某个进程使用的虚拟空间，每次调入一个页面到物理内存中，push进去，然后每次调出，则删除，用于FIFO这个算法，来表示哪些虚拟空间可以使用swap。

然后一个是调入的时机，是在缺页中断的时候，具体上面写了。

调出的时机，参考那个挂羊头卖狗肉的说明，一个是alloc的时候消极调出，一个使用时钟中断的方式积极调出。

（最后哔哔一句，实验二和三其实是一回事，那个pte是核心这句话也没毛病，明白了整个过程就行了。最重要应该是三块，一个是，物理页框的划分，以及和其相对应的alloc和free的分配物理页框。第二个是逻辑地址线性地址和物理地址的变化，也就是给出一个地址，如何进行映射到物理地址上面去。第三个是虚拟地址的管理。就是在磁盘上还是在内存中，这个管理过程——理论上，应该是通过对pte存在位的不同来探索的。）